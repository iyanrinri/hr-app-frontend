{"file":"useAuth-Dt3T5Rvc.js","mappings":";;AAQO,MAAM,UAAU,MAAM;AACV,YAAA;AACf,QAAM,QAAQ,SAAA;AACd,QAAM,YAAY,aAAA;AAClB,QAAM,EAAE,KAAA,IAAS,WAAA;AAEjB,QAAM,UAAU,IAAI,KAAK;AAEzB,QAAM,QAAQ,OAAO,YAAiD;AAClE,UAAM,aAAa,MAAM,OAAO;AAChC,YAAQ,QAAQ;AAChB,QAAI;AAIA,YAAM,MAAM,aACN,QAAQ,UAAU,gBAClB;AAEN,YAAM,WAAW,MAAM,OAAsB,KAAK;AAAA,QAC9C,QAAQ;AAAA,QACR,MAAM;AAAA;AAAA,MAAA,CAET;AAED,YAAM,EAAE,cAAc,KAAA,IAAS;AAC/B,gBAAU,QAAQ,cAAc,IAAI;AAKpC,YAAM,eAAe,aAAa,IAAI,UAAU,eAAe;AAC/D,iBAAW,YAAY;AAAA,IAI3B,SAAS,OAAY;AAChB,YAAM,UAAU,MAAM,MAAM,WAAW;AACvC,YAAM,IAAI,MAAM,OAAO;AAAA,IAC5B,UAAA;AACI,cAAQ,QAAQ;AAAA,IACpB;AAAA,EACJ;AAEA,QAAM,SAAS,YAAY;AACvB,UAAM,aAAa,MAAM,OAAO;AAEhC,QAAI;AACC,YAAM,MAAM,aACP,QAAQ,UAAU,iBAClB;AAIL,YAAM,OAAO,KAAK;AAAA,QACd,QAAQ;AAAA,MAAA,CACX;AAAA,IACN,SAAS,OAAO;AACZ,cAAQ,MAAM,0BAA0B,KAAK;AAAA,IAEjD,UAAA;AACI,gBAAU,UAAA;AACV,YAAM,eAAe,aAAa,IAAI,UAAU,gBAAgB;AAChE,aAAO,WAAW,YAAY;AAAA,IAClC;AAAA,EACJ;AAEA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAER;","names":[],"sources":["../../../../composables/useAuth.ts"],"sourcesContent":["import { useAuthStore } from '@/stores/auth'\nimport type { LoginResponse } from '@/types/auth'\n\n// In Nuxt, we can use useFetch or just plain $fetch. \n// For better control matching your axiom setup, we can use a custom composable or $fetch with interceptors \n// OR just port axios. But Nuxt native way is preferred.\n\n// Composable for Auth Logic\nexport const useAuth = () => {\n    const router = useRouter()\n    const route = useRoute()\n    const authStore = useAuthStore()\n    const { $api } = useNuxtApp() // Assuming we will create a plugin for api\n\n    const loading = ref(false)\n\n    const login = async (payload: { email: string; password: string }) => {\n        const tenantSlug = route.params.tenant_slug as string\n        loading.value = true\n        try {\n            // Using a simple fetch wrapper or axios\n            // We need to implement the API service first, but for now assuming direct call logic\n            // Construct URL with tenant_slug if available\n            const url = tenantSlug \n                ? `/api/${tenantSlug}/auth/login` \n                : '/api/auth/login'\n\n            const response = await $fetch<LoginResponse>(url, {\n                method: 'POST',\n                body: payload,\n                // Nuxt proxy will handle /api -> backend\n            })\n\n            const { access_token, user } = response\n            authStore.setAuth(access_token, user)\n            \n            // Cookie is set by store automatically\n            \n            // Redirect\n            const redirectPath = tenantSlug ? `/${tenantSlug}/dashboard` : '/dashboard'\n            navigateTo(redirectPath)\n            \n            // Simple alert/toast (we can add a Toast library later)\n            // console.log('Logged in successfully') \n        } catch (error: any) {\n             const message = error.data?.message || 'Login failed'\n             throw new Error(message)\n        } finally {\n            loading.value = false\n        }\n    }\n\n    const logout = async () => {\n        const tenantSlug = route.params.tenant_slug as string\n        \n        try {\n             const url = tenantSlug \n                ? `/api/${tenantSlug}/auth/logout` \n                : '/api/auth/logout'\n\n             // We attempt to call the backend logout\n             // We don't block heavily on this, but we try to execute it.\n             await $fetch(url, {\n                 method: 'POST'\n             })\n        } catch (error) {\n            console.error('Logout API call failed', error)\n            // We continue to client-side logout anyway\n        } finally {\n            authStore.clearAuth()\n            const redirectPath = tenantSlug ? `/${tenantSlug}/auth/login` : '/auth/login'\n            return navigateTo(redirectPath) \n        }\n    }\n\n    return {\n        login,\n        logout,\n        loading\n    }\n}\n"],"version":3}