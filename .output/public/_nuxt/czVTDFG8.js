import{g as U,a_ as w,af as W,aZ as q,ac as z,c as A,b0 as R,ae as I,K as O,bf as G,b1 as S,bi as v,bj as Z,ak as J,i as Q,y as N,bk as B,b2 as X,bl as Y,bm as F,j as $,bn as K,ai as k,bo as aa,k as ea,bp as ta}from"./DX_cbf2s.js";const na={trailing:!0};function ra(a,e=25,s={}){if(s={...na,...s},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let i,n,D=[],r,t;const _=(f,h)=>(r=sa(a,f,h),r.finally(()=>{if(r=null,s.trailing&&t&&!n){const g=_(f,t);return t=null,g}}),r),m=function(...f){return s.trailing&&(t=f),r||new Promise(h=>{const g=!n&&s.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const l=s.leading?i:_(this,f);t=null;for(const d of D)d(l);D=[]},e),g?(i=_(this,f),h(i)):D.push(h)})},o=f=>{f&&(clearTimeout(f),n=null)};return m.isPending=()=>!!n,m.cancel=()=>{o(n),D=[],t=null},m.flush=()=>{if(o(n),!t||r)return;const f=t;return t=null,_(this,f)},m}async function sa(a,e,s){return await a.apply(e,s)}const H=Symbol.for("nuxt:client-only"),da=U({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(a,{slots:e,attrs:s}){const i=w(!1);W(()=>{i.value=!0});const n=R();return n&&(n._nuxtClientOnly=!0),I(H,!0),()=>{if(i.value){const _=e.default?.();return _&&_.length===1?[q(_[0],s)]:_}const D=e.fallback||e.placeholder;if(D)return z(D);const r=a.fallback||a.placeholder||"",t=a.fallbackTag||a.placeholderTag||"span";return A(t,s,r)}}}),oa=a=>a==="defer"||a===!1;function _a(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;ia(a[0],a[1])&&a.unshift(e);let[s,i,n={}]=a,D=!1;const r=O(()=>G(s));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=S();n.server??=!0,n.default??=ca,n.getCachedData??=x,n.lazy??=!1,n.immediate??=!0,n.deep??=v.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function _(){const l={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(l.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=V(t,r.value,i,n,l.cachedData)),()=>t._asyncData[r.value].execute(l)}const m=_(),o=t._asyncData[r.value];o._deps++;const f=n.server!==!1&&t.payload.serverRendered;{let l=function(u){const c=t._asyncData[u];c?._deps&&(c._deps--,c._deps===0&&c?._off())};const d=R();if(d&&f&&n.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const u=d._nuxtOnBeforeMountCbs;Z(()=>{u.forEach(c=>{c()}),u.splice(0,u.length)}),J(()=>u.splice(0,u.length))}const C=d&&(d._nuxtClientOnly||Q(H,!1));f&&t.isHydrating&&(o.error.value||o.data.value!=null)?(o.pending.value=!1,o.status.value=o.error.value?"error":"success"):d&&(!C&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?d._nuxtOnBeforeMountCbs.push(m):n.immediate&&m();const b=F(),y=N(r,(u,c)=>{if((u||c)&&u!==c){D=!0;const M=t._asyncData[c]?.data.value!==v.value,L=t._asyncDataPromises[c]!==void 0,T={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[u]?._init){let E;c&&M?E=t._asyncData[c].data.value:(E=n.getCachedData(u,t,{cause:"initial"}),T.cachedData=E),t._asyncData[u]=V(t,u,i,n,E)}t._asyncData[u]._deps++,c&&l(c),(n.immediate||M||L)&&t._asyncData[u].execute(T),ta(()=>{D=!1})}},{flush:"sync"}),p=n.watch?N(n.watch,()=>{D||t._asyncData[r.value]?._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};b&&B(()=>{y(),p(),l(r.value)})}const h={data:P(()=>t._asyncData[r.value]?.data),pending:P(()=>t._asyncData[r.value]?.pending),status:P(()=>t._asyncData[r.value]?.status),error:P(()=>t._asyncData[r.value]?.error),refresh:(...l)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...l):_()(),execute:(...l)=>h.refresh(...l),clear:()=>{const l=t._asyncData[r.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}j(t,r.value)}},g=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>h);return Object.assign(g,h),g}function P(a){return O({get(){return a()?.value},set(e){const s=a();s&&(s.value=e)}})}function ia(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function Da(a){const e=S();if(a in e.payload.data||(e.payload.data[a]=v.value),e._asyncData[a]){const s=e._asyncData[a];s._deps++,F()&&B(()=>{s._deps--,s._deps===0&&s?._off()})}return{data:O({get(){return e._asyncData[a]?.data.value??e.payload.data[a]},set(s){e._asyncData[a]?e._asyncData[a].data.value=s:e.payload.data[a]=s}})}}async function ba(a){await new Promise(s=>X(s));const e=a?Y(a):void 0;await S().hooks.callHookParallel("app:data:refresh",e)}function j(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=v.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=v.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function la(a,e){const s={};for(const i of e)s[i]=a[i];return s}function V(a,e,s,i,n){a.payload._errors[e]??=v.errorValue;const D=i.getCachedData!==x,r=s,t=i.deep?$:w,_=n!=null,m=a.hook("app:data:refresh",async f=>{(!f||f.includes(e))&&await o.execute({cause:"refresh:hook"})}),o={data:t(_?n:i.default()),pending:w(!_),error:K(a.payload._errors,e),status:w("idle"),execute:(...f)=>{const[h,g=void 0]=f,l=h&&g===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&oa(l.dedupe??i.dedupe))return a._asyncDataPromises[e];if(l.cause==="initial"||a.isHydrating){const b="cachedData"in l?l.cachedData:i.getCachedData(e,a,{cause:l.cause??"refresh:manual"});if(b!=null)return a.payload.data[e]=o.data.value=b,o.error.value=v.errorValue,o.status.value="success",Promise.resolve(b)}o.pending.value=!0,o._abortController&&o._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),o._abortController=new AbortController,o.status.value="pending";const d=new AbortController,C=new Promise((b,y)=>{try{const p=l.timeout??i.timeout,u=ua([o._abortController?.signal,l?.signal],d.signal,p);if(u.aborted){const c=u.reason;y(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const c=u.reason;y(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(r(a,{signal:u})).then(b,y)}catch(p){y(p)}}).then(async b=>{let y=b;i.transform&&(y=await i.transform(b)),i.pick&&(y=la(y,i.pick)),a.payload.data[e]=y,o.data.value=y,o.error.value=v.errorValue,o.status.value="success"}).catch(b=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==C||o._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&b instanceof DOMException&&b.name==="AbortError")return o.status.value="idle",a._asyncDataPromises[e];o.error.value=aa(b),o.data.value=ea(i.default()),o.status.value="error"}).finally(()=>{o.pending.value=!1,d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=C,a._asyncDataPromises[e]},_execute:ra((...f)=>o.execute(...f),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{m(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),D||k(()=>{a._asyncData[e]?._init||(j(a,e),o.execute=()=>Promise.resolve(),o.data.value=v.value)})}};return o}const ca=()=>v.value,x=(a,e,s)=>{if(e.isHydrating)return e.payload.data[a];if(s.cause!=="refresh:manual"&&s.cause!=="refresh:hook")return e.static.data[a]};function ua(a,e,s){const i=a.filter(r=>!!r);if(typeof s=="number"&&s>=0){const r=AbortSignal.timeout?.(s);r&&i.push(r)}if(AbortSignal.any)return AbortSignal.any(i);const n=new AbortController;for(const r of i)if(r.aborted){const t=r.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const D=()=>{const t=i.find(_=>_.aborted)?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const r of i)r.addEventListener?.("abort",D,{once:!0,signal:e});return n.signal}export{da as _,Da as a,ba as r,_a as u};
